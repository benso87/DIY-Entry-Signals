//@version=5
//
// Author: benso87
// benso87.com
//
// Credit to:
// The_Caretaker for BBWP and PMARP indicators 
//
indicator(title='DIY Entry Signals', shorttitle='DIY Signals', format=format.price, precision=2, timeframe='', timeframe_gaps=true, overlay=true, max_bars_back=500)

noColor = color.new(color.white, transp=100)
//////////////////////////////////////////////////////////////
// Inputs

// Signal Types
includeLong		= input.bool (true, title='Long', inline='1', group='Signal Types')
includeShort	= input.bool (true, title='Short', inline='2', group='Signal Types')
onlyConfirmed   = input.bool (true, title='Only Confirmed Candles', inline='3', group='Signal Types')
useSigCheck     = input.bool (false, title='No More Signals For # Bars', inline='5', group='Signal Types')
sigCheckBars    = input.int  (10, title='', minval=1, maxval=50, inline='5', group='Signal Types')
plotType        = input.string('Shape', title='Signal Marker', options=['Shape', 'Dot'], group='Signal Types')

// Price
priceSource = input.source(close, title='Price Source', group='Price')

// Moving Averages
maSource    = input.source  (close, title='Source', inline='source', group='Moving Averages')
includeMA1	= input.bool	(true, title='', inline='MA 1', group='Moving Averages')
ma1Color 	= input.color	(#ffeb3b, title='MA 1', inline='MA 1', group='Moving Averages')
ma1Length 	= input.int		(21, title='Length', minval=1, inline='MA 1', group='Moving Averages')
ma1Type 	= input.string	('EMA', title='Type', options=['SMA','EMA'], inline='MA 1', group='Moving Averages')
includeMA2	= input.bool	(true, title='', inline='MA 2', group='Moving Averages')
ma2Color 	= input.color	(#00e676, title='MA 2', inline='MA 2', group='Moving Averages')
ma2Length 	= input.int		(55, title='Length', minval=1, inline='MA 2', group='Moving Averages')
ma2Type 	= input.string	('EMA', title='Type', options=['SMA','EMA'], inline='MA 2', group='Moving Averages')
includeMA3	= input.bool	(true, title='', inline='MA 3', group='Moving Averages')
ma3Color 	= input.color	(#00bcd4, title='MA 3', inline='MA 3', group='Moving Averages')
ma3Length 	= input.int		(100, title='Length', minval=1, inline='MA 3', group='Moving Averages')
ma3Type 	= input.string	('EMA', title='Type', options=['SMA','EMA'], inline='MA 3', group='Moving Averages')
includeMA4	= input.bool	(true, title='', inline='MA 4', group='Moving Averages')
ma4Color 	= input.color	(#e040fb, title='MA 4', inline='MA 4', group='Moving Averages')
ma4Length 	= input.int		(200, title='Length', minval=1, inline='MA 4', group='Moving Averages')
ma4Type 	= input.string	('EMA', title='Type', options=['SMA','EMA'], inline='MA 4', group='Moving Averages')

// Moving Average Crosses 
maCrosses    = input.bool   (false, title='Highlight moving average crosses', group='Moving Average Crosses', inline='1')
useCross1    = input.bool   (false, title='Pair 1', group='Moving Average Crosses', inline='pair1')
cross1Color1 = input.color  (color.new(color.silver, transp=50), title='', group='Moving Average Crosses', inline='pair1')
cross1Color2 = input.color  (color.new(color.purple, transp=50), title='', group='Moving Average Crosses', inline='pair1')
cross1ma1Str = input.string ('MA 1', title='', options=['MA 1', 'MA 2', 'MA 3', 'MA 4'], group='Moving Average Crosses', inline='pair1')
cross1ma2Str = input.string ('MA 2', title='', options=['MA 1', 'MA 2', 'MA 3', 'MA 4'], group='Moving Average Crosses', inline='pair1')
useCross2    = input.bool   (false, title='Pair 2', group='Moving Average Crosses', inline='pair2')
cross2Color1 = input.color  (color.new(color.yellow, transp=50), title='', group='Moving Average Crosses', inline='pair2')
cross2Color2 = input.color  (color.new(color.red, transp=50), title='', group='Moving Average Crosses', inline='pair2')
cross2ma1Str = input.string ('MA 2', title='', options=['MA 1', 'MA 2', 'MA 3', 'MA 4'], group='Moving Average Crosses', inline='pair2')
cross2ma2Str = input.string ('MA 4', title='', options=['MA 1', 'MA 2', 'MA 3', 'MA 4'], group='Moving Average Crosses', inline='pair2')
useCross3    = input.bool   (false, title='Pair 3', group='Moving Average Crosses', inline='pair3')
cross3Color1 = input.color  (color.new(color.blue, transp=50), title='', group='Moving Average Crosses', inline='pair3')
cross3Color2 = input.color  (color.new(color.orange, transp=50), title='', group='Moving Average Crosses', inline='pair3')
cross3ma1Str = input.string ('MA 3', title='', options=['MA 1', 'MA 2', 'MA 3', 'MA 4'], group='Moving Average Crosses', inline='pair3')
cross3ma2Str = input.string ('MA 4', title='', options=['MA 1', 'MA 2', 'MA 3', 'MA 4'], group='Moving Average Crosses', inline='pair3')

// RSI
rsiSource = input.source (close, title='Source', group='RSI')
rsiPeriod = input.int    (14, minval=1, title='RSI Period', group='RSI')

// Stochastic
stochSource = input.source  (close, title='Source', group='Stochastic')
periodK 	= input.int     (14, title='K Length', minval=1, group='Stochastic')
smoothK 	= input.int     (3, title='K Smoothing', minval=1, group='Stochastic')
periodD 	= input.int     (3, title='D Smoothing', minval=1, group='Stochastic')
kdSig       = input.bool    (false, title='K & D', group='Stochastic', tooltip='Turn this on to only signal when both K and D are in the selected range.')

// Stoch RSI
srsiSmoothK = input.int   (3, title='K', minval=1, group='Stochastic RSI')
srsiSmoothD = input.int   (3, title='D', minval=1, group='Stochastic RSI')
srsiLength  = input.int   (14, title='Stoch Length', minval=1, group='Stochastic RSI')
srsiKDSig   = input.bool  (false, title='K & D', group='Stochastic RSI', tooltip='Turn this on to only signal when both K and D are in the selected range.')

// Bollinger Bands
bbSource    = input.source (close, title='Source', group='Bollinger Bands')
bbLength    = input.int    (20, minval=1, group='Bollinger Bands')
bbMult      = input.float  (2.0, minval=0.001, maxval=50, title="StdDev", group='Bollinger Bands')
bbBiasMAStr = input.string ('MA 4', title='Moving Average for Bias', options=['MA 1', 'MA 2', 'MA 3', 'MA 4'], group='Bollinger Bands', tooltip='Bias is determined by the BB midline being above or below the chosen moving average.')
plotBB      = input.bool   (false, title='Plot', group='Bollinger Bands')
bbFill      = input.color  (noColor, title='Fill Color', group='Bollinger Bands')
biasFill    = input.bool   (false, title='Color Based on Bias', group='Bollinger Bands')
longFill    = input.color  (color.new(color.green, transp=80), title='Long Bias', group='Bollinger Bands')
shortFill   = input.color  (color.new(color.red, transp=80), title='Short Bias', group='Bollinger Bands')

// BBWP
bbwpPriceSource = input.source  (close, title='Source', inline='1', group='BBWP')
bbwpBasisType   = input.string  ('SMA', title='Basis Type', options=['SMA', 'EMA', 'VWMA'], inline='1', group='BBWP')
bbwpLength      = input.int     (13, title='Length', minval=1, inline='2', group='BBWP')
bbwpLookback    = input.int     (252, title='Lookback', minval=1, inline='2', group='BBWP')
bbwpMax			= input.float	(35, title='BBWP Max', minval=0, maxval=100, step=0.01,	inline='3', group='BBWP')
bbwpMin			= input.float	(0, title='BBWP Min', minval=0, maxval=100, step=0.01,	inline='3', group='BBWP')

// PMARP
pmarpSource     = input.source  (close, title='Source', inline='1', group='PMARP')
pmarpLookback	= input.int		(350, title='Lookback', minval=1, maxval=1900, inline='1', group='PMARP')
pmarpLength     = input.int     (20, title='PMAR Length', minval=1, inline='2', group='PMARP')
pmarpMAType     = input.string  ('VWMA', title='MA Type', options=[ 'SMA', 'EMA', 'HMA', 'RMA', 'VWMA' ], inline='2', group='PMARP')

// ADX/DMI
length = input.int(14, title="ADX DI Length", group='ADX/DMI')

// Days Off
useOffDays  = input.bool (false, title='Days Off', group='Days Off')
offSun      = input.bool (true, title='Sunday', group='Days Off')
offMon      = input.bool (false, title='Monday', group='Days Off')
offTue      = input.bool (false, title='Tuesday', group='Days Off')
offWed      = input.bool (false, title='Wednesday', group='Days Off')
offThur     = input.bool (false, title='Thursday', group='Days Off')
offFri      = input.bool (false, title='Friday', group='Days Off')
offSat      = input.bool (true, title='Saturday', group='Days Off')

// Time Off
useTimeOff = input.bool (false, title='Time Off', group='Time Off')
startTimeH = input.int  (12, title='Start (UTC)', minval=0, maxval=23, group='Time Off', inline='start')
startTimeM = input.int  (0, title=':', minval=0, maxval=59, group='Time Off', inline='start')
stopTimeH  = input.int  (4, title='Stop (UTC)', minval=0, maxval=23, group='Time Off', inline='stop')
stopTimeM  = input.int  (0, title=':', minval=0, maxval=59, group='Time Off', inline='stop')

// Long Conditions
usePriceLong    	= input.bool    (true, title='Price', inline='price', group='Long Conditions')
priceLongAB     	= input.string  ('Above', title='', options=['Above', 'Below'], inline='price', group='Long Conditions')
priceMaLongStr   	= input.string  ('MA 1', title='', options=['MA 1', 'MA 2', 'MA 3', 'MA 4'], inline='price', group='Long Conditions')
i_ma1Above2   		= input.bool    (false, title='MA 1 > MA 2', inline='ma above 1', group='Long Conditions')
i_ma2Above3   		= input.bool    (false, title='MA 2 > MA 3', inline='ma above 2', group='Long Conditions')
i_ma3Above4   		= input.bool    (false, title='MA 3 > MA 4', inline='ma above 3', group='Long Conditions')
includeRSILong  	= input.bool    (false, title='RSI', inline='rsi', group='Long Conditions')
rsiLowLong   		= input.float   (38, title='Above', inline='rsi', group='Long Conditions')
rsiHighLong   		= input.float   (62, title='Below', inline='rsi', group='Long Conditions')
includeStochLong 	= input.bool    (false, title='Stoch', inline='stoch', group='Long Conditions')
stochKAboveD  		= input.bool    (false, title='K > D', inline='stoch', group='Long Conditions')
useStochRangeLong 	= input.bool    (false, title='Stoch In Range?',inline='stoch 2', group='Long Conditions')
stochLowLong  		= input.float   (20, title='Low', inline='stoch 2', group='Long Conditions')
stochHighLong  		= input.float   (80, title='High', inline='stoch 2', group='Long Conditions')
includeSRSILong     = input.bool    (false, title='Stoch RSI', inline='srsi', group='Long Conditions')
srsiLowLong         = input.float   (0, title='Low', minval=0, maxval=100, inline='srsi', group='Long Conditions')
srsiHighLong        = input.float   (10, title='High', minval=0, maxval=100, inline='srsi', group='Long Conditions')
includeBBLong       = input.bool    (false, title='Bollinger Bands', inline='bb', group='Long Conditions')
includBBBiasLong    = input.bool    (false, title='Bias', inline='bb', group='Long Conditions', tooltip='Signal only if the BB midline is above the chose moving average.')
includeBBTestLong   = input.bool    (false, title='Test Lower (Experimental)', inline='bb', group='Long Conditions', tooltip='Signal only on a test of the lower band.')
includeBBWPLong  	= input.bool    (false, title='BBWP', inline='bbwp', group='Long Conditions')
includePMARPLong 	= input.bool    (false, title='PMARP', inline='pmarp', group='Long Conditions')
pmarpLongAB     	= input.string  ('Below', title='', options=['Above', 'Below'], inline='pmarp', group='Long Conditions')
pmarpThresholdLong	= input.float   (15, title='', inline='pmarp', group='Long Conditions')
useDMILong     		= input.bool    (false, title='DMI', inline='dmi', group='Long Conditions')
dmiPNLong      		= input.string  ('Positive', title='', options=['Positive', 'Negative'], inline='dmi', group='Long Conditions')
dmiFlipLong			= input.bool    (false, title='Only on flip', inline='dmi', group='Long Conditions', tooltip='Signal only on the bar where the DMI flip occurs.')
useADXLong     		= input.bool    (false, title='ADX Range', inline='adx', group='Long Conditions')
adxABLong      		= input.string  ('Below', title='', options=['Above', 'Below'], inline='adx', group='Long Conditions')
adxThresholdLong  	= input.float   (20, title='', inline='adx', group='Long Conditions')
useADXDirLong		= input.bool    (false, title='ADX Direction', inline='adx 2', group='Long Conditions')
adxDirLong			= input.string  ('Rising', title='', options=['Rising', 'Falling'], inline='adx 2', group='Long Conditions')

// Short Conditions
usePriceShort    	= input.bool    (true, title='Price', inline='price', group='Short Conditions')
priceShortAB    	= input.string  ('Above', title='', options=['Above', 'Below'], inline='price', group='Short Conditions')
priceMaShortStr   	= input.string  ('MA 1', title='', options=['MA 1', 'MA 2', 'MA 3', 'MA 4'], inline='price', group='Short Conditions')
i_ma1Below2   		= input.bool    (false, title='MA 1 < MA 2', inline='ma below 1', group='Short Conditions')
i_ma2Below3   		= input.bool    (false, title='MA 2 < MA 3', inline='ma below 2', group='Short Conditions')
i_ma3Below4   		= input.bool    (false, title='MA 3 < MA 4', inline='ma below 3', group='Short Conditions')
includeRSIShort  	= input.bool    (false, title='RSI', inline='rsi', group='Short Conditions')
rsiLowShort   		= input.float   (38, title='Above', inline='rsi', group='Short Conditions')
rsiHighShort  		= input.float   (62, title='Below', inline='rsi', group='Short Conditions')
includeStochShort 	= input.bool    (false, title='Stoch', inline='stoch', group='Short Conditions')
stochKBelowD  		= input.bool    (false, title='K < D', inline='stoch', group='Short Conditions')
useStochRangeShort  = input.bool    (false, title='Stoch In Range?',inline='stoch 2', group='Short Conditions')
stochLowShort  		= input.float   (20, title='Low', inline='stoch 2', group='Short Conditions')
stochHighShort  	= input.float   (80, title='High', inline='stoch 2', group='Short Conditions')
includeSRSIShort    = input.bool    (false, title='Stoch RSI', inline='srsi', group='Short Conditions')
srsiLowShort        = input.float   (90, title='Low', minval=0, maxval=100, inline='srsi', group='Short Conditions')
srsiHighShort       = input.float   (100, title='High', minval=0, maxval=100, inline='srsi', group='Short Conditions')
includeBBShort      = input.bool    (false, title='Bollinger Bands', inline='bb', group='Short Conditions')
includBBBiasShort   = input.bool    (false, title='Bias', inline='bb', group='Short Conditions', tooltip='Signal only if the BB midline is below the chosen moving average.')
includeBBTestShort  = input.bool    (false, title='Test Upper (Experimental)', inline='bb', group='Short Conditions', tooltip='Signal only on a test of the upper band.')
includeBBWPShort 	= input.bool    (false, title='BBWP', inline='bbwp', group='Short Conditions')
includePMARPShort 	= input.bool    (false, title='PMARP', inline='pmarp', group='Short Conditions')
pmarpShortAB    	= input.string  ('Above', title='', options=['Above', 'Below'], inline='pmarp', group='Short Conditions')
pmarpThresholdShort	= input.float   (85, title='', inline='pmarp', group='Short Conditions')
useDMIShort     	= input.bool    (false, title='DMI', inline='dmi', group='Short Conditions')
dmiPNShort     		= input.string  ('Negative', title='', options=['Positive', 'Negative'], inline='dmi', group='Short Conditions')
dmiFlipShort		= input.bool    (false, title='Only on flip', inline='dmi', group='Short Conditions', tooltip='Signal only on the bar where the DMI flip occurs.')
useADXShort     	= input.bool    (false, title='ADX Range', inline='adx', group='Short Conditions')
adxABShort     		= input.string  ('Below', title='', options=['Above', 'Below'], inline='adx', group='Short Conditions')
adxThresholdShort  	= input.float   (20, title='', inline='adx', group='Short Conditions')
useADXDirShort		= input.bool    (false, title='ADX Direction', inline='adx 2', group='Short Conditions')
adxDirShort			= input.string  ('Rising', title='', options=['Rising', 'Falling'], inline='adx 2', group='Short Conditions')


//////////////////////////////////////////////////////////////
// Calculations

// Function to calculate moving averages based on chosen type
f_ma(source, length, type) =>
    switch type
        'SMA' => ta.sma(source, length)
        'EMA' => ta.ema(source, length)
        'RMA' => ta.rma(source, length)
        'WMA' => ta.wma(source, length)

// Moving Averages
ma1 = f_ma(maSource, ma1Length, ma1Type)
ma2 = f_ma(maSource, ma2Length, ma2Type)
ma3 = f_ma(maSource, ma3Length, ma3Type)
ma4 = f_ma(maSource, ma4Length, ma4Type)

// Function to convert chosen MA to MA series
f_convertMA (ma) =>
    switch ma
        'MA 1' => ma1
        'MA 2' => ma2
        'MA 3' => ma3
        'MA 4' => ma4

ma1Above2 	= ma1 > ma2
ma1Above3 	= ma1 > ma3
ma1Above4 	= ma1 > ma4

ma2Above1 	= ma2 > ma1
ma2Above3 	= ma2 > ma3
ma2Above4 	= ma2 > ma4

ma3Above1 	= ma3 > ma1
ma3Above2 	= ma3 > ma2
ma3Above4 	= ma3 > ma4

ma4Above1 	= ma4 > ma1
ma4Above2 	= ma4 > ma2
ma4Above3 	= ma4 > ma3

// Moving average crossover checks
cross1ma1 = f_convertMA(cross1ma1Str)
cross1ma2 = f_convertMA(cross1ma2Str)
cross2ma1 = f_convertMA(cross2ma1Str)
cross2ma2 = f_convertMA(cross2ma2Str)
cross3ma1 = f_convertMA(cross3ma1Str)
cross3ma2 = f_convertMA(cross3ma2Str)

cross1Up = maCrosses and useCross1 ? ta.crossover(cross1ma1, cross1ma2) : false
cross1Down = maCrosses and useCross1 ? ta.crossunder(cross1ma1, cross1ma2) : false
cross2Up = maCrosses and useCross2 ? ta.crossover(cross2ma1, cross2ma2) : false
cross2Down = maCrosses and useCross2 ? ta.crossunder(cross2ma1, cross2ma2) : false
cross3Up = maCrosses and useCross3 ? ta.crossover(cross3ma1, cross3ma2) : false
cross3Down = maCrosses and useCross3 ? ta.crossunder(cross3ma1, cross3ma2) : false

crossColor = cross3Up ? cross3Color1 : cross3Down ? cross3Color2 : cross2Up ? cross2Color1 : cross2Down ? cross2Color2 : cross1Up ? cross1Color1 : cross1Down ? cross1Color2 : na

// Price check conversions
priceMaLong = f_convertMA(priceMaLongStr)
priceMaShort = f_convertMA(priceMaShortStr)

// RSI
up = ta.rma(math.max(ta.change(rsiSource), 0), rsiPeriod)
down = ta.rma(-math.min(ta.change(rsiSource), 0), rsiPeriod)
rsi = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))

// Stochastic
k = ta.sma(ta.stoch(stochSource, high, low, periodK), smoothK)
d = ta.sma(k, periodD)

stochInRangeLong = kdSig ? stochHighLong >= k and k >= stochLowLong and stochHighLong >= d and d >= stochLowLong : stochHighLong >= k and k >= stochLowLong
stochInRangeShort = kdSig ? stochHighShort >= k and k >= stochLowShort and stochHighShort >= d and d >= stochLowShort : stochHighShort >= k and k >= stochLowShort

// Stoch RSI
srsiK = ta.sma(ta.stoch(rsi, rsi, rsi, srsiLength), srsiSmoothK)
srsiD = ta.sma(srsiK, srsiSmoothD)

srsiInRangeLong = srsiKDSig ? srsiHighLong >= srsiK and srsiK >= srsiLowLong and srsiHighLong >= srsiD and srsiD >= srsiLowLong : srsiHighLong >= srsiK and srsiK >= srsiLowLong
srsiInRangeShort = srsiKDSig ? srsiHighShort >= srsiK and srsiK >= srsiLowShort and srsiHighShort >= srsiD and srsiD >= srsiLowShort : srsiHighShort >= srsiK and srsiK >= srsiLowShort

// Bollinger Bands
basis = ta.sma(bbSource, bbLength)
dev = bbMult * ta.stdev(bbSource, bbLength)
upper = basis + dev
lower = basis - dev

bbUpTest = (high >= upper and close < upper and close > basis) or (close[1] >= upper[1] and close < upper and close > basis)
bbLowTest = (low <= lower and close > lower and close < basis) or (close[1] <= lower[1] and close > lower and close < basis)

bbBiasMA = f_convertMA(bbBiasMAStr)
longBias = basis > bbBiasMA
shortBias = basis < bbBiasMA

fillColor = biasFill and longBias ? longFill : biasFill and shortBias ? shortFill : bbFill

// BBWP
// Credit to The_Caretaker
f_maType ( _price, _len, _type ) =>
    _type == 'SMA' ? ta.sma ( _price, _len ) : _type == 'EMA' ? ta.ema ( _price, _len ) : ta.vwma ( _price, _len )

f_bbwp ( _price, _bbwLen, _bbwpLen, _type ) =>
    float _basis = f_maType ( _price, _bbwLen, _type )
    float _dev = ta.stdev ( _price, _bbwLen )
    _bbw = ( _basis + _dev - ( _basis - _dev )) / _basis
    _bbwSum = 0.0
    _len = bar_index < _bbwpLen ? bar_index : _bbwpLen
    for _i = 1 to _len by 1
        _bbwSum += ( _bbw[_i] > _bbw ? 0 : 1 )
        _bbwSum
    _return = bar_index >= _bbwLen ? ( _bbwSum / _len) * 100 : na
    _return

bbwp	= f_bbwp ( bbwpPriceSource, bbwpLength, bbwpLookback, bbwpBasisType )

// PMARP
// Credit to The_Caretaker
f_prior_sum ( _P, _X ) =>
    math.sum ( _P[1], _X - 1 )

f_ma_val ( _P, _typ, _len ) =>
    _typ == 'SMA' ? ta.sma ( _P, _len ) : _typ == 'EMA' ? ta.ema ( _P, _len ) : _typ == 'RMA' ? ta.rma ( _P, _len ) : _typ == 'HMA' ? ta.hma ( _P, _len ) : ta.vwma ( _P, _len )

f_pmarp ( _price, _pmarLen, _pmarpLen, _type_p ) =>
    _pmar = math.abs ( _price / f_ma_val ( _price, _type_p, _pmarLen ))
    _pmarpSum = 0
    _len = bar_index < _pmarpLen ? bar_index : _pmarpLen
    for i = 1 to _len by 1
        _pmarpSum += ( _pmar[i] > _pmar ? 0 : 1 )
        _pmarpSum
    _return = bar_index >= _pmarLen ? _pmarpSum / _len * 100 : na

ma          = f_ma_val ( pmarpSource, pmarpMAType, pmarpLength )
pmar        = pmarpSource / ma
pmarp       = f_pmarp ( pmarpSource, pmarpLength, pmarpLookback, pmarpMAType ) 

// ADX/DMI
dUp = ta.change(high)
dDown = -ta.change(low)
plusDM = na(dUp) ? na : (dUp > dDown and dUp > 0 ? dUp : 0)
minusDM = na(dDown) ? na : (dDown > dUp and dDown > 0 ? dDown : 0)
trur = ta.rma(ta.tr, length)
plus = fixnan(100 * ta.rma(plusDM, length) / trur)
minus = fixnan(100 * ta.rma(minusDM, length) / trur)
sum = plus + minus
adx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), length)
diff = plus - minus

// Calculations and variables to determine if a signal has been plotted recently
var sigCheckArrayL = array.new_int (0)
var sigCheckArrayS = array.new_int (0)

sigCheckL = array.sum(sigCheckArrayL) > 0 ? true : false
sigCheckS = array.sum(sigCheckArrayS) > 0 ? true : false

// For testing signal checks
// plotchar(sigCheckL, title='sigCheckL', char='.', color=noColor)
// plotchar(sigCheckS, title='sigCheckS', char='.', color=noColor)

// Time Off
f_timeSession (H, M) =>
    h = H < 10 ? '0' + str.tostring(H) : str.tostring(H)
    m = M < 10 ? '0' + str.tostring(M) : str.tostring(M)
    t = h + m

startTime = startTimeH * 100 + startTimeM
startTimeStr = f_timeSession(startTimeH, startTimeM)
stopTime = stopTimeH * 100 + stopTimeM
stopTimeStr = f_timeSession(stopTimeH, stopTimeM)

timeOffSession = startTime <= stopTime ? time(timeframe.period, session=startTimeStr + '-' + stopTimeStr) : time(timeframe.period, session='0000-' + stopTimeStr + ',' + startTimeStr + '-2359')

// Signals
dayOff = useOffDays and ((offSun and dayofweek == dayofweek.sunday) or (offMon and dayofweek == dayofweek.monday) or (offTue and dayofweek == dayofweek.tuesday) or (offWed and dayofweek == dayofweek.wednesday) or (offThur and dayofweek == dayofweek.thursday) or (offFri and dayofweek == dayofweek.friday) or (offSat and dayofweek == dayofweek.saturday))
timeOff = useTimeOff and timeOffSession

priceSignalLong     = not usePriceLong or (priceLongAB == 'Above' and priceSource >= priceMaLong) or (priceLongAB == 'Below' and priceSource <= priceMaLong)
priceSignalShort    = not usePriceShort or (priceShortAB == 'Above' and priceSource >= priceMaShort) or (priceShortAB == 'Below' and priceSource <= priceMaShort)

maSignalLong 		= (not i_ma1Above2 or ma1Above2) and (not i_ma2Above3 or ma2Above3) and (not i_ma3Above4 or ma3Above4)
maSignalShort		= (not i_ma1Below2 or ma2Above1) and (not i_ma2Below3 or ma3Above2) and (not i_ma3Below4 or ma4Above3)

rsiSignalLong		= not includeRSILong or (rsiHighLong > rsi and rsi > rsiLowLong) 
rsiSignalShort		= not includeRSIShort or (rsiHighShort > rsi and rsi > rsiLowShort)

stochSignalLong		= not includeStochLong or ((not useStochRangeLong or stochInRangeLong) and (not stochKAboveD or k > d))
stochSignalShort	= not includeStochShort or ((not useStochRangeShort or stochInRangeShort) and (not stochKBelowD or k < d))

srsiSignalLong      = not includeSRSILong or srsiInRangeLong
srsiSignalShort     = not includeSRSIShort or srsiInRangeShort

bbSignalLong        = not includeBBLong or ((not includBBBiasLong or longBias) and (not includeBBTestLong or bbLowTest))
bbSignalShort       = not includeBBShort or ((not includBBBiasShort or shortBias) and (not includeBBTestShort or bbUpTest))

bbwpSignalLong		= not includeBBWPLong or (bbwp < bbwpMax and bbwp > bbwpMin)
bbwpSignalShort		= not includeBBWPShort or (bbwp < bbwpMax and bbwp > bbwpMin)

pmarpSignalLong		= not includePMARPLong or (pmarpLongAB == 'Above' and pmarp >= pmarpThresholdLong) or (pmarpLongAB == 'Below' and pmarp <= pmarpThresholdLong)
pmarpSignalShort	= not includePMARPShort or (pmarpShortAB == 'Above' and pmarp >= pmarpThresholdShort) or (pmarpShortAB == 'Below' and pmarp <= pmarpThresholdShort)

dmiSignalLong       = not useDMILong or ((not dmiFlipLong or (diff > 0 and diff [1] <= 0) or (diff < 0 and diff[1] >= 0)) and ((dmiPNLong == 'Positive' and diff > 0) or (dmiPNLong == 'Negative' and diff < 0)))
dmiSignalShort      = not useDMIShort or ((not dmiFlipShort or (diff > 0 and diff [1] <= 0) or (diff < 0 and diff[1] >= 0)) and ((dmiPNShort == 'Positive' and diff > 0) or (dmiPNShort == 'Negative' and diff < 0)))

adxSignalLong       = not useADXLong or (adxABLong == 'Above' and adx >= adxThresholdLong) or (adxABLong == 'Below' and adx <= adxThresholdLong)
adxSignalShort      = not useADXShort or (adxABShort == 'Above' and adx >= adxThresholdShort) or (adxABShort == 'Below' and adx <= adxThresholdShort)

adxDirSignalLong	= not useADXDirLong or (adxDirLong == 'Rising' and adx >= adx[1]) or (adxDirLong == 'Falling' and adx <= adx[1])
adxDirSignalShort	= not useADXDirShort or (adxDirShort == 'Rising' and adx >= adx[1]) or (adxDirShort == 'Falling' and adx <= adx[1])

longSignal 			= includeLong and not dayOff and not timeOff and (not useSigCheck or not sigCheckL) and (not onlyConfirmed or barstate.isconfirmed) and priceSignalLong and maSignalLong and rsiSignalLong and stochSignalLong and srsiSignalLong and bbSignalLong and bbwpSignalLong and pmarpSignalLong and dmiSignalLong and adxSignalLong and adxDirSignalLong
shortSignal 		= includeShort and not dayOff and not timeOff and (not useSigCheck or not sigCheckS) and (not onlyConfirmed or barstate.isconfirmed) and priceSignalShort and maSignalShort and rsiSignalShort and stochSignalShort and srsiSignalShort and bbSignalShort and bbwpSignalShort and pmarpSignalShort and dmiSignalShort and adxSignalShort and adxDirSignalShort

// Check if a new signal should not be plotted

array.push(sigCheckArrayL, longSignal ? 1 : 0)
array.push(sigCheckArrayS, shortSignal ? 1 : 0)

if array.size(sigCheckArrayL) > sigCheckBars
    array.remove(sigCheckArrayL, 0)
    
if array.size(sigCheckArrayS) > sigCheckBars
    array.remove(sigCheckArrayS, 0)

//////////////////////////////////////////////////////////////
// Plots

// Background
bgcolor(dayOff or timeOff ? color.new(color.purple, transp=80) : crossColor)

// Moving Averages
plot(includeMA1 ? ma1 : na, title='MA 1', color=ma1Color, linewidth=2, offset=0)
plot(includeMA2 ? ma2 : na, title='MA 2', color=ma2Color, linewidth=2, offset=0)
plot(includeMA3 ? ma3 : na, title='MA 3', color=ma3Color, linewidth=2, offset=0)
plot(includeMA4 ? ma4 : na, title='MA 4', color=ma4Color, linewidth=2, offset=0)

// Bollinger Bands
plot(plotBB ? basis : na, title='Basis', color=color.orange, linewidth=1)
p1 = plot(plotBB ? upper : na, title='Upper', color=color.blue, linewidth=2)
p2 = plot(plotBB ? lower : na, title='Lower', color=color.blue, linewidth=2)
fill(p1, p2, title='BB Background', color=fillColor)

// Signals
plotshape(plotType == 'Shape' ? longSignal : na,  title='Long',  location=location.belowbar, style=shape.triangleup, size=size.auto, color=color.blue)
plotchar(plotType == 'Dot'  ? longSignal : na, title='Long', location=location.belowbar, char='•', color=color.blue)
plotshape(plotType == 'Shape' ? shortSignal : na, title='Short', location=location.abovebar, style=shape.triangledown, size=size.small, color=color.red)
plotchar(plotType == 'Dot' ? shortSignal : na, title='Short', location=location.abovebar, char='•', color=color.red)


//////////////////////////////////////////////////////////////
// Alerts

alertcondition(longSignal, title='Long Signal', message='DIY Long Signal')
alertcondition(shortSignal, title='Short Signal', message='DIY Short Signal')
alertcondition(longSignal or shortSignal, title='Any Signal', message='DIY Signal')

alertcondition(cross1Up or cross1Down, title='MA Pair 1 Cross', message='DIY MA Cross Signal')
alertcondition(cross2Up or cross2Down, title='MA Pair 2 Cross', message='DIY MA Cross Signal')
alertcondition(cross3Up or cross3Down, title='MA Pair 3 Cross', message='DIY MA Cross Signal')

//////////////////////////////////////////////////////////////

// Testing
// plotchar(srsiK, 'k', char='.', color=noColor)
// plotchar(srsiD, 'd', char='.', color=noColor)